#region

using System;
using HC.Analytics.Mathematics.LinearAlgebra;
using HC.Analytics.Probability.Random;

#endregion

namespace HC.Analytics.Probability.Distributions.Continuous
{
    public class LogarithmicDist : AbstractUnivContDist
    {
        #region Members

        /// <summary>
        /// Own instance
        /// </summary>
        private static readonly LogarithmicDist m_ownInstance = new LogarithmicDist(
            1, new RngWrapper(INT_RND_SEED));

        /// <summary>
        /// Distribution's parameter
        /// </summary>
        private double m_dblA;

        // cached vars for method NextDouble(a) (for performance only)
        private double m_dblAPrev = -1.0;
        private double m_dblH;
        private double m_dblT;

        #endregion

        #region Constants

        private const int INT_RND_SEED = 14;

        #endregion

        #region Constructors

        public LogarithmicDist(
            double dblA,
            RngWrapper rng)
            : base(rng)
        {
            SetState(
                dblA);
        }

        #endregion

        #region Parameters

        public double A
        {
            get { return m_dblA; }
            set { m_dblA = value; }
        }

        #endregion

        #region Initializaiton

        private void SetState(
            double dblA)
        {
            m_dblA = dblA;
        }

        #endregion

        #region Public

        /**
         * Returns a random number from the distribution; bypasses the internal state.
         */

        public override double NextDouble()
        {
            /******************************************************************
             *                                                                *
             *      Logarithmic Distribution - Inversion/Transformation       *
             *                                                                *
             ******************************************************************
             *                                                                *
             * The algorithm combines Inversion and Transformation.           *
             * It is based on the following fact: A random variable X from    *
             * the Logarithmic distribution has the property that X for fixed *
             * Y=y is Geometric distributed with P(X=x|Y=y)=(1-y)*y^(x-1) (*) *
             * where Y has distribution function F(y)=ln(1-y)/ln(1-p).        *
             * So first random numbers y are generated by simple Inversion,   *
             * then k=(long int) (1+ln(u)/ln(y)) is a Geometric random number *
             * and because of (*) a Logarithmic one.                          *
             * To speed up the algorithm squeezes are used as well as the     *
             * fact, that many of the random numbers are 1 or 2 (depending on *
             * special circumstances).                                        *
             * On an IBM/PC 486 optimal performance is achieved, if for p<.97 *
             * simple inversion is used and otherwise the transformation.     *
             * On an IBM/PC 286 inversion should be restricted to p<.90.      *
             *                                                                *
             ******************************************************************
             *                                                                *
             * FUNCTION:    - lsk  samples a random number from the           *
             *                Logarithmic distribution with                   *
             *                parameter  0 < p < 1 .                          *
             * REFERENCE:   - A.W. Kemp (1981): Efficient generation of       *
             *                logarithmically distributed pseudo-random       *
             *                variables, Appl. Statist. 30, 249-253.          *
             * SUBPROGRAMS: - drand(seed) ... (0,1)-Uniform generator with    *
             *                unsigned long integer *seed.                    *
             *                                                                *
             ******************************************************************/
            double u, v, p, q;
            int k;

            if (A != m_dblAPrev)
            {
                // Set-up
                m_dblAPrev = A;
                if (A < 0.97)
                {
                    m_dblT = -A/Math.Log(1.0 - A);
                }
                else
                {
                    m_dblH = Math.Log(1.0 - A);
                }
            }

            u = m_rng.NextDouble();
            if (A < 0.97)
            {
                // Inversion/Chop-down
                k = 1;
                p = m_dblT;
                while (u > p)
                {
                    //PrintToScreen.WriteLine("u="+u+", p="+p);
                    u -= p;
                    k++;
                    p *= A*(k - 1.0)/k;
                }
                return k;
            }

            if (u > A)
            {
                return 1; // Transformation
            }
            u = m_rng.NextDouble();
            v = u;
            q = 1.0 - Math.Exp(v*m_dblH);
            if (u <= q*q)
            {
                k = (int) (1 + Math.Log(u)/Math.Log(q));
                return k;
            }
            if (u > q)
            {
                return 1;
            }
            return 2;
        }

        /**
         * Returns a string representation of the receiver.
         */

        public override string ToString()
        {
            return "LogarithmicDist(" + A + ")";
        }

        public override double Cdf(double dblX)
        {
            throw new NotImplementedException();
        }

        public override double CdfInv(double dblProbability)
        {
            throw new NotImplementedException();
        }

        public override double Pdf(double dblX)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region StaticMethods

        public static double PdfStatic(
            double dblA,
            double dblX)
        {
            m_ownInstance.SetState(
                dblA);

            return m_ownInstance.Pdf(dblX);
        }

        public static double CdfStatic(
            double dblA,
            double dblX)
        {
            m_ownInstance.SetState(
                dblA);

            return m_ownInstance.Cdf(dblX);
        }

        public static double CdfInvStatic(
            double dblA,
            double dblProbability)
        {
            m_ownInstance.SetState(
                dblA);

            return m_ownInstance.CdfInv(dblProbability);
        }

        public static double NextDoubleStatic(
            double dblA)
        {
            m_ownInstance.SetState(
                dblA);

            return m_ownInstance.NextDouble();
        }

        public static double[] NextDoubleArrStatic(
            double dblA,
            int intSampleSize)
        {
            m_ownInstance.SetState(
                dblA);

            return m_ownInstance.NextDoubleArr(intSampleSize);
        }

        public static Vector NextDoubleVectorStatic(
            double dblA,
            int intSampleSize)
        {
            m_ownInstance.SetState(
                dblA);

            return m_ownInstance.NextDoubleVector(intSampleSize);
        }

        #endregion
    }
}
